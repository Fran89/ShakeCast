#!/usr/local/bin/perl

use strict;
use warnings;

use FindBin;
use lib "$FindBin::Bin/../../lib";

use Carp;

use CGI;
use JSON::XS;

use SC;
use API::Event;
use API::APIUtil;
use SC::Event;
use SC::Shakemap;
use SC::Product;
use SC::Server;


SC->initialize;
my $test_dir = SC->config->{'RootDir'} . '/test_data';
my $data_dir = SC->config->{'DataRoot'};
my $default_options = API::APIUtil::config_options();

my $self = new CGI;
my (@args) = split '/', $ENV{PATH_INFO};
shift @args;
my $action = shift @args;

print "Content-Type: application/json\n\n";
if (not defined *{$action} ) {
} else {
    SC->log(0, "user: task is $action $args[0]");

	no strict 'refs';
    # perform the requested action
    #eval {
	my $json =  &{ $action }( @args );
	print JSON::XS->new->utf8->encode(API::APIUtil::stringfy($json));
    #};
}


    # Authenticated
sub event_list {
    my $start = ($self->param('start')) ? ($self->param('start'))-1 : 0;
    my $length = ($self->param('length')) ? $self->param('length') : 100;
    my $type = ($self->param('type')) ? lc($self->param('type')) : '';
    my $age = $self->param('age') || 'week';
    my $timestamp = age_trans($age);
    my $options = {'start' => $start,
		    'length' => $length,
		    'type' => $type,
		    'age' => $age,
		    'timestamp' => $timestamp,
		    };
    my $events;
    my $count;
	if ($type =~ /scenario|major/i) {
		$events = new API::Event->event_list($type);
	} elsif ($type =~ /test/i) {
		$events = get_test_events();
	} elsif ($age) {
		($count, $events) = new API::Event->newer_than($options);
	}

	return $events;
}

    # Authenticated
sub datatables {
    my $start = ($self->param('start')) ? ($self->param('start'))-1 : 0;
    my $length = ($self->param('length')) ? $self->param('length') : 
      (($default_options->{'topics_per_page'}) ? $default_options->{'topics_per_page'} : 200);
    my $type = ($self->param('type')) ? lc($self->param('type')) : '';
    my $age = $self->param('age') || 'week';
    my $timestamp = age_trans($age);
    my $options = {'start' => $start,
		    'length' => $length,
		    'type' => $type,
		    'age' => $age,
		    'timestamp' => $timestamp,
		    };
    my $events;
    my $count;
	if ($type =~ /scenario|major/i) {
		$events = new API::Event->event_list($type);
	} elsif ($type =~ /test/i) {
		$events = get_test_events();
	} elsif ($age) {
		($count, $events) = new API::Event->newer_than($options);
	}
	my $datatables = {};
	my @aData;
	$datatables->{"total"} = $count;
	$datatables->{"start"} = $start;
	$datatables->{"length"} = scalar @$events;
	$datatables->{"data"} = API::APIUtil::stringfy($events);

	return $datatables;
}

sub age_trans {
    my $age = (@_ ? shift : 'day');
	my $span;
	if ($age =~ /day/i) {
		$span = 1;
	} elsif ($age =~ /week/i) {
		$span = 7;
	} elsif ($age =~ /month/i) {
		$span = 30;
	} elsif ($age =~ /year/i) {
		$span = 365;
	} elsif ($age =~ /all/i) {
		$span = time/86400;
	} elsif ($age =~ /\d+/) {
	  $span = $age;
	}
    my $time = time - $span*86400;
    my ($sec, $min, $hr, $mday, $mon, $yr);
		($sec, $min, $hr, $mday, $mon, $yr) = gmtime $time;

    sprintf ("%04d-%02d-%02d",
	     $yr+1900, $mon+1, $mday);


}

sub check_test_dir {
    unless (-d $test_dir) {
        mkdir $test_dir or exit;
    }
}

sub get_test_events {
    my @test_events;
    my $xml;

    check_test_dir();
    opendir TESTDIR, $test_dir or quit("Can't open $test_dir\: $!");
    # exclude .* files
    my @files = grep !/^\./, readdir TESTDIR;
    # exclude non-directories
    my @dirs = grep -d, map "$test_dir/$_", @files;
    foreach my $dir (@dirs) {
        $dir =~ m#([^/\\]+$)#;     # last component only
        $xml = read_xml($1, 'event');
        SC->log(4, "event XML: $xml");
        $xml =~ s/\?event_version/1/g;
        SC->log(4, "event XML: $xml");
        eval {
            my $event = API::Event->from_xml($xml)
                or exit;
			$event->{shakemap_id}=$event->{event_id};
			$event->{shakemap_version} = 1;
            push @test_events, $event;
			$event->{product} = copy_test($event->{event_id});
        };
        return if $@;
    }
    return \@test_events;
}
    
sub read_xml {
    my ($event_id, $type) = @_;

    my $fname = "$test_dir/$event_id/${type}_template.xml";
    open XML, "< $fname" or exit;
    my @lines = <XML>;
    close XML;
    chomp @lines;
    return join(' ', @lines);
}

sub copy_test {
    my ($event_id) = @_;
    my $xml;
    my $event;
    my $source_dir = "$test_dir/$event_id";
    my $dest_dir = "$data_dir/$event_id"."-1";

	return if (-d $dest_dir);
	eval {mkpath($dest_dir);};
	SC->log(4, "mkpath product dir: $dest_dir");
	return if $@;
	
    opendir TESTDIR, $source_dir or quit("Can't open $source_dir\: $!");
    # exclude .* files
    my @files = grep !/^\./, readdir TESTDIR;
    # exclude non-files
	#print @files,"\n";
    my @products = grep -f, map "$source_dir/$_", @files;
    foreach my $product (@products) {
        copy $product, $dest_dir;
    }
    return \@products;
}

# returns a list of all products that should be polled for new events, etc.
sub product_types {
	my @products;
	
    undef $SC::errstr;
    eval {
		my $sth = SC->dbh->prepare(qq/
			select product_type
			  from product_type/);
		$sth->execute;
		while (my @p = $sth->fetchrow_array()) {
			push @products, @p;
		}
    };
    return @products;
}

sub local_products {
	my $temp_dir = SC->config->{'TemplateDir'} . '/xml';
	my @local_products;
	if (-d $temp_dir) {
		if (opendir TEMPDIR, $temp_dir) {
			# exclude .* files
			my @files = grep !/^\./, readdir TEMPDIR;
			# exclude non-directories
			closedir(TEMPDIR);
		
			foreach my $file (@files) {
				if ($file =~ m#([^/\\]+)\.tt$#) {     # last component only
					my $temp_file = $1.".tt";
					my $output_file = $1;
					$output_file =~ s/_/\./;
					push @local_products, $output_file;
				}
			}
		}
	}
    return \@local_products;
}

sub create_test {
    my ($event_id) = @_;
	
    check_test_dir();
    my $template_dir = "$test_dir/${event_id}_scte";
    exit if (-d $template_dir);
    mkdir $template_dir or exit;
    my $event = SC::Event->current_version($event_id);
    exit unless $event;
    my $xml = make_test_xml($event->to_xml);
    open OUT, "> $template_dir/event_template.xml" or exit;
    print OUT "$xml\n";
    close OUT;
    my $shakemap = SC::Shakemap->current_version($event_id);
    return "No shakemap with ID $event_id" unless $shakemap;
    $xml = make_test_xml($shakemap->to_xml);
    open OUT, "> $template_dir/shakemap_template.xml" or exit;
    print OUT "$xml\n";
    close OUT;
    my @products = SC::Product->current_version($event_id);
    exit if $SC::errstr;
    exit unless @products > 0;
    $xml = make_test_xml($products[0]->to_xml);
    open OUT, "> $template_dir/product_template.xml" or exit;
    print OUT "$xml\n";
    close OUT;
    foreach my $product (@products) {
        copy $product->abs_file_path, $template_dir;
    }
		my @local_products = local_products();
    foreach my $local_product (@local_products) {
        copy $shakemap->product_dir .'/' . $local_product, $template_dir;
    }
	return;
}



sub make_test_xml {
    my ($xml) = @_;
    $xml =~ s/event_id="([^"]+)"/event_id="$1_scte"/gm;
    $xml =~ s/shakemap_id="([^"]+)"/shakemap_id="$1_scte"/gm;
    $xml =~ s/event_version="([^"]+)"/event_version="?event_version"/gm;
    $xml =~ s/shakemap_version="([^"]+)"/shakemap_version="?event_version"/gm;
    $xml =~ s/event_type="[^"]+"/event_type="TEST"/gm;
    $xml =~ s/product_type="[^"]+"/product_type="?product_type"/gm;
    return $xml;
}



